(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["three~5ee2e9fb"],{"9f13":function(t,s,i){"use strict";i.d(s,"a",(function(){return J}));const e=[];for(let G=0;G<256;G++)e[G]=(G<16?"0":"")+G.toString(16);Math.PI,Math.PI;function r(t,s,i){return Math.max(s,Math.min(i,t))}class h{constructor(t=0,s=0,i=0,e=1){this._x=t,this._y=s,this._z=i,this._w=e}static slerp(t,s,i,e){return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."),i.slerpQuaternions(t,s,e)}static slerpFlat(t,s,i,e,r,h,n){let a=i[e+0],o=i[e+1],c=i[e+2],l=i[e+3];const u=r[h+0],m=r[h+1],x=r[h+2],y=r[h+3];if(0===n)return t[s+0]=a,t[s+1]=o,t[s+2]=c,void(t[s+3]=l);if(1===n)return t[s+0]=u,t[s+1]=m,t[s+2]=x,void(t[s+3]=y);if(l!==y||a!==u||o!==m||c!==x){let t=1-n;const s=a*u+o*m+c*x+l*y,i=s>=0?1:-1,e=1-s*s;if(e>Number.EPSILON){const r=Math.sqrt(e),h=Math.atan2(r,s*i);t=Math.sin(t*h)/r,n=Math.sin(n*h)/r}const r=n*i;if(a=a*t+u*r,o=o*t+m*r,c=c*t+x*r,l=l*t+y*r,t===1-n){const t=1/Math.sqrt(a*a+o*o+c*c+l*l);a*=t,o*=t,c*=t,l*=t}}t[s]=a,t[s+1]=o,t[s+2]=c,t[s+3]=l}static multiplyQuaternionsFlat(t,s,i,e,r,h){const n=i[e],a=i[e+1],o=i[e+2],c=i[e+3],l=r[h],u=r[h+1],m=r[h+2],x=r[h+3];return t[s]=n*x+c*l+a*m-o*u,t[s+1]=a*x+c*u+o*l-n*m,t[s+2]=o*x+c*m+n*u-a*l,t[s+3]=c*x-n*l-a*u-o*m,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,s,i,e){return this._x=t,this._y=s,this._z=i,this._w=e,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,s){if(!t||!t.isEuler)throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const i=t._x,e=t._y,r=t._z,h=t._order,n=Math.cos,a=Math.sin,o=n(i/2),c=n(e/2),l=n(r/2),u=a(i/2),m=a(e/2),x=a(r/2);switch(h){case"XYZ":this._x=u*c*l+o*m*x,this._y=o*m*l-u*c*x,this._z=o*c*x+u*m*l,this._w=o*c*l-u*m*x;break;case"YXZ":this._x=u*c*l+o*m*x,this._y=o*m*l-u*c*x,this._z=o*c*x-u*m*l,this._w=o*c*l+u*m*x;break;case"ZXY":this._x=u*c*l-o*m*x,this._y=o*m*l+u*c*x,this._z=o*c*x+u*m*l,this._w=o*c*l-u*m*x;break;case"ZYX":this._x=u*c*l-o*m*x,this._y=o*m*l+u*c*x,this._z=o*c*x-u*m*l,this._w=o*c*l+u*m*x;break;case"YZX":this._x=u*c*l+o*m*x,this._y=o*m*l+u*c*x,this._z=o*c*x-u*m*l,this._w=o*c*l-u*m*x;break;case"XZY":this._x=u*c*l-o*m*x,this._y=o*m*l-u*c*x,this._z=o*c*x+u*m*l,this._w=o*c*l+u*m*x;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+h)}return!1!==s&&this._onChangeCallback(),this}setFromAxisAngle(t,s){const i=s/2,e=Math.sin(i);return this._x=t.x*e,this._y=t.y*e,this._z=t.z*e,this._w=Math.cos(i),this._onChangeCallback(),this}setFromRotationMatrix(t){const s=t.elements,i=s[0],e=s[4],r=s[8],h=s[1],n=s[5],a=s[9],o=s[2],c=s[6],l=s[10],u=i+n+l;if(u>0){const t=.5/Math.sqrt(u+1);this._w=.25/t,this._x=(c-a)*t,this._y=(r-o)*t,this._z=(h-e)*t}else if(i>n&&i>l){const t=2*Math.sqrt(1+i-n-l);this._w=(c-a)/t,this._x=.25*t,this._y=(e+h)/t,this._z=(r+o)/t}else if(n>l){const t=2*Math.sqrt(1+n-i-l);this._w=(r-o)/t,this._x=(e+h)/t,this._y=.25*t,this._z=(a+c)/t}else{const t=2*Math.sqrt(1+l-i-n);this._w=(h-e)/t,this._x=(r+o)/t,this._y=(a+c)/t,this._z=.25*t}return this._onChangeCallback(),this}setFromUnitVectors(t,s){let i=t.dot(s)+1;return i<Number.EPSILON?(i=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=i):(this._x=0,this._y=-t.z,this._z=t.y,this._w=i)):(this._x=t.y*s.z-t.z*s.y,this._y=t.z*s.x-t.x*s.z,this._z=t.x*s.y-t.y*s.x,this._w=i),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(r(this.dot(t),-1,1)))}rotateTowards(t,s){const i=this.angleTo(t);if(0===i)return this;const e=Math.min(1,s/i);return this.slerp(t,e),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return 0===t?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t,s){return void 0!==s?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(t,s)):this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,s){const i=t._x,e=t._y,r=t._z,h=t._w,n=s._x,a=s._y,o=s._z,c=s._w;return this._x=i*c+h*n+e*o-r*a,this._y=e*c+h*a+r*n-i*o,this._z=r*c+h*o+i*a-e*n,this._w=h*c-i*n-e*a-r*o,this._onChangeCallback(),this}slerp(t,s){if(0===s)return this;if(1===s)return this.copy(t);const i=this._x,e=this._y,r=this._z,h=this._w;let n=h*t._w+i*t._x+e*t._y+r*t._z;if(n<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,n=-n):this.copy(t),n>=1)return this._w=h,this._x=i,this._y=e,this._z=r,this;const a=1-n*n;if(a<=Number.EPSILON){const t=1-s;return this._w=t*h+s*this._w,this._x=t*i+s*this._x,this._y=t*e+s*this._y,this._z=t*r+s*this._z,this.normalize(),this._onChangeCallback(),this}const o=Math.sqrt(a),c=Math.atan2(o,n),l=Math.sin((1-s)*c)/o,u=Math.sin(s*c)/o;return this._w=h*l+this._w*u,this._x=i*l+this._x*u,this._y=e*l+this._y*u,this._z=r*l+this._z*u,this._onChangeCallback(),this}slerpQuaternions(t,s,i){return this.copy(t).slerp(s,i)}random(){const t=Math.random(),s=Math.sqrt(1-t),i=Math.sqrt(t),e=2*Math.PI*Math.random(),r=2*Math.PI*Math.random();return this.set(s*Math.cos(e),i*Math.sin(r),i*Math.cos(r),s*Math.sin(e))}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,s=0){return this._x=t[s],this._y=t[s+1],this._z=t[s+2],this._w=t[s+3],this._onChangeCallback(),this}toArray(t=[],s=0){return t[s]=this._x,t[s+1]=this._y,t[s+2]=this._z,t[s+3]=this._w,t}fromBufferAttribute(t,s){return this._x=t.getX(s),this._y=t.getY(s),this._z=t.getZ(s),this._w=t.getW(s),this}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}}h.prototype.isQuaternion=!0;class n{constructor(t=0,s=0,i=0){this.x=t,this.y=s,this.z=i}set(t,s,i){return void 0===i&&(i=this.z),this.x=t,this.y=s,this.z=i,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,s){switch(t){case 0:this.x=s;break;case 1:this.y=s;break;case 2:this.z=s;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t,s){return void 0!==s?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,s)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,s){return this.x=t.x+s.x,this.y=t.y+s.y,this.z=t.z+s.z,this}addScaledVector(t,s){return this.x+=t.x*s,this.y+=t.y*s,this.z+=t.z*s,this}sub(t,s){return void 0!==s?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,s)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,s){return this.x=t.x-s.x,this.y=t.y-s.y,this.z=t.z-s.z,this}multiply(t,s){return void 0!==s?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(t,s)):(this.x*=t.x,this.y*=t.y,this.z*=t.z,this)}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,s){return this.x=t.x*s.x,this.y=t.y*s.y,this.z=t.z*s.z,this}applyEuler(t){return t&&t.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(o.setFromEuler(t))}applyAxisAngle(t,s){return this.applyQuaternion(o.setFromAxisAngle(t,s))}applyMatrix3(t){const s=this.x,i=this.y,e=this.z,r=t.elements;return this.x=r[0]*s+r[3]*i+r[6]*e,this.y=r[1]*s+r[4]*i+r[7]*e,this.z=r[2]*s+r[5]*i+r[8]*e,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const s=this.x,i=this.y,e=this.z,r=t.elements,h=1/(r[3]*s+r[7]*i+r[11]*e+r[15]);return this.x=(r[0]*s+r[4]*i+r[8]*e+r[12])*h,this.y=(r[1]*s+r[5]*i+r[9]*e+r[13])*h,this.z=(r[2]*s+r[6]*i+r[10]*e+r[14])*h,this}applyQuaternion(t){const s=this.x,i=this.y,e=this.z,r=t.x,h=t.y,n=t.z,a=t.w,o=a*s+h*e-n*i,c=a*i+n*s-r*e,l=a*e+r*i-h*s,u=-r*s-h*i-n*e;return this.x=o*a+u*-r+c*-n-l*-h,this.y=c*a+u*-h+l*-r-o*-n,this.z=l*a+u*-n+o*-h-c*-r,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const s=this.x,i=this.y,e=this.z,r=t.elements;return this.x=r[0]*s+r[4]*i+r[8]*e,this.y=r[1]*s+r[5]*i+r[9]*e,this.z=r[2]*s+r[6]*i+r[10]*e,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,s){return this.x=Math.max(t.x,Math.min(s.x,this.x)),this.y=Math.max(t.y,Math.min(s.y,this.y)),this.z=Math.max(t.z,Math.min(s.z,this.z)),this}clampScalar(t,s){return this.x=Math.max(t,Math.min(s,this.x)),this.y=Math.max(t,Math.min(s,this.y)),this.z=Math.max(t,Math.min(s,this.z)),this}clampLength(t,s){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(t,Math.min(s,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,s){return this.x+=(t.x-this.x)*s,this.y+=(t.y-this.y)*s,this.z+=(t.z-this.z)*s,this}lerpVectors(t,s,i){return this.x=t.x+(s.x-t.x)*i,this.y=t.y+(s.y-t.y)*i,this.z=t.z+(s.z-t.z)*i,this}cross(t,s){return void 0!==s?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(t,s)):this.crossVectors(this,t)}crossVectors(t,s){const i=t.x,e=t.y,r=t.z,h=s.x,n=s.y,a=s.z;return this.x=e*a-r*n,this.y=r*h-i*a,this.z=i*n-e*h,this}projectOnVector(t){const s=t.lengthSq();if(0===s)return this.set(0,0,0);const i=t.dot(this)/s;return this.copy(t).multiplyScalar(i)}projectOnPlane(t){return a.copy(this).projectOnVector(t),this.sub(a)}reflect(t){return this.sub(a.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const s=Math.sqrt(this.lengthSq()*t.lengthSq());if(0===s)return Math.PI/2;const i=this.dot(t)/s;return Math.acos(r(i,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const s=this.x-t.x,i=this.y-t.y,e=this.z-t.z;return s*s+i*i+e*e}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,s,i){const e=Math.sin(s)*t;return this.x=e*Math.sin(i),this.y=Math.cos(s)*t,this.z=e*Math.cos(i),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,s,i){return this.x=t*Math.sin(s),this.y=i,this.z=t*Math.cos(s),this}setFromMatrixPosition(t){const s=t.elements;return this.x=s[12],this.y=s[13],this.z=s[14],this}setFromMatrixScale(t){const s=this.setFromMatrixColumn(t,0).length(),i=this.setFromMatrixColumn(t,1).length(),e=this.setFromMatrixColumn(t,2).length();return this.x=s,this.y=i,this.z=e,this}setFromMatrixColumn(t,s){return this.fromArray(t.elements,4*s)}setFromMatrix3Column(t,s){return this.fromArray(t.elements,3*s)}setFromEuler(t){return this.x=t._x,this.y=t._y,this.z=t._z,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,s=0){return this.x=t[s],this.y=t[s+1],this.z=t[s+2],this}toArray(t=[],s=0){return t[s]=this.x,t[s+1]=this.y,t[s+2]=this.z,t}fromBufferAttribute(t,s,i){return void 0!==i&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(s),this.y=t.getY(s),this.z=t.getZ(s),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const t=2*(Math.random()-.5),s=Math.random()*Math.PI*2,i=Math.sqrt(1-t**2);return this.x=i*Math.cos(s),this.y=i*Math.sin(s),this.z=t,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}n.prototype.isVector3=!0;const a=new n,o=new h;class c{constructor(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(t,s,i,e,r,h,n,a,o,c,l,u,m,x,y,d){const p=this.elements;return p[0]=t,p[4]=s,p[8]=i,p[12]=e,p[1]=r,p[5]=h,p[9]=n,p[13]=a,p[2]=o,p[6]=c,p[10]=l,p[14]=u,p[3]=m,p[7]=x,p[11]=y,p[15]=d,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return(new c).fromArray(this.elements)}copy(t){const s=this.elements,i=t.elements;return s[0]=i[0],s[1]=i[1],s[2]=i[2],s[3]=i[3],s[4]=i[4],s[5]=i[5],s[6]=i[6],s[7]=i[7],s[8]=i[8],s[9]=i[9],s[10]=i[10],s[11]=i[11],s[12]=i[12],s[13]=i[13],s[14]=i[14],s[15]=i[15],this}copyPosition(t){const s=this.elements,i=t.elements;return s[12]=i[12],s[13]=i[13],s[14]=i[14],this}setFromMatrix3(t){const s=t.elements;return this.set(s[0],s[3],s[6],0,s[1],s[4],s[7],0,s[2],s[5],s[8],0,0,0,0,1),this}extractBasis(t,s,i){return t.setFromMatrixColumn(this,0),s.setFromMatrixColumn(this,1),i.setFromMatrixColumn(this,2),this}makeBasis(t,s,i){return this.set(t.x,s.x,i.x,0,t.y,s.y,i.y,0,t.z,s.z,i.z,0,0,0,0,1),this}extractRotation(t){const s=this.elements,i=t.elements,e=1/l.setFromMatrixColumn(t,0).length(),r=1/l.setFromMatrixColumn(t,1).length(),h=1/l.setFromMatrixColumn(t,2).length();return s[0]=i[0]*e,s[1]=i[1]*e,s[2]=i[2]*e,s[3]=0,s[4]=i[4]*r,s[5]=i[5]*r,s[6]=i[6]*r,s[7]=0,s[8]=i[8]*h,s[9]=i[9]*h,s[10]=i[10]*h,s[11]=0,s[12]=0,s[13]=0,s[14]=0,s[15]=1,this}makeRotationFromEuler(t){t&&t.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");const s=this.elements,i=t.x,e=t.y,r=t.z,h=Math.cos(i),n=Math.sin(i),a=Math.cos(e),o=Math.sin(e),c=Math.cos(r),l=Math.sin(r);if("XYZ"===t.order){const t=h*c,i=h*l,e=n*c,r=n*l;s[0]=a*c,s[4]=-a*l,s[8]=o,s[1]=i+e*o,s[5]=t-r*o,s[9]=-n*a,s[2]=r-t*o,s[6]=e+i*o,s[10]=h*a}else if("YXZ"===t.order){const t=a*c,i=a*l,e=o*c,r=o*l;s[0]=t+r*n,s[4]=e*n-i,s[8]=h*o,s[1]=h*l,s[5]=h*c,s[9]=-n,s[2]=i*n-e,s[6]=r+t*n,s[10]=h*a}else if("ZXY"===t.order){const t=a*c,i=a*l,e=o*c,r=o*l;s[0]=t-r*n,s[4]=-h*l,s[8]=e+i*n,s[1]=i+e*n,s[5]=h*c,s[9]=r-t*n,s[2]=-h*o,s[6]=n,s[10]=h*a}else if("ZYX"===t.order){const t=h*c,i=h*l,e=n*c,r=n*l;s[0]=a*c,s[4]=e*o-i,s[8]=t*o+r,s[1]=a*l,s[5]=r*o+t,s[9]=i*o-e,s[2]=-o,s[6]=n*a,s[10]=h*a}else if("YZX"===t.order){const t=h*a,i=h*o,e=n*a,r=n*o;s[0]=a*c,s[4]=r-t*l,s[8]=e*l+i,s[1]=l,s[5]=h*c,s[9]=-n*c,s[2]=-o*c,s[6]=i*l+e,s[10]=t-r*l}else if("XZY"===t.order){const t=h*a,i=h*o,e=n*a,r=n*o;s[0]=a*c,s[4]=-l,s[8]=o*c,s[1]=t*l+r,s[5]=h*c,s[9]=i*l-e,s[2]=e*l-i,s[6]=n*c,s[10]=r*l+t}return s[3]=0,s[7]=0,s[11]=0,s[12]=0,s[13]=0,s[14]=0,s[15]=1,this}makeRotationFromQuaternion(t){return this.compose(m,t,x)}lookAt(t,s,i){const e=this.elements;return p.subVectors(t,s),0===p.lengthSq()&&(p.z=1),p.normalize(),y.crossVectors(i,p),0===y.lengthSq()&&(1===Math.abs(i.z)?p.x+=1e-4:p.z+=1e-4,p.normalize(),y.crossVectors(i,p)),y.normalize(),d.crossVectors(p,y),e[0]=y.x,e[4]=d.x,e[8]=p.x,e[1]=y.y,e[5]=d.y,e[9]=p.y,e[2]=y.z,e[6]=d.z,e[10]=p.z,this}multiply(t,s){return void 0!==s?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(t,s)):this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,s){const i=t.elements,e=s.elements,r=this.elements,h=i[0],n=i[4],a=i[8],o=i[12],c=i[1],l=i[5],u=i[9],m=i[13],x=i[2],y=i[6],d=i[10],p=i[14],z=i[3],M=i[7],w=i[11],_=i[15],g=e[0],b=e[4],f=e[8],S=e[12],E=e[1],C=e[5],V=e[9],P=e[13],q=e[2],F=e[6],k=e[10],T=e[14],v=e[3],A=e[7],B=e[11],R=e[15];return r[0]=h*g+n*E+a*q+o*v,r[4]=h*b+n*C+a*F+o*A,r[8]=h*f+n*V+a*k+o*B,r[12]=h*S+n*P+a*T+o*R,r[1]=c*g+l*E+u*q+m*v,r[5]=c*b+l*C+u*F+m*A,r[9]=c*f+l*V+u*k+m*B,r[13]=c*S+l*P+u*T+m*R,r[2]=x*g+y*E+d*q+p*v,r[6]=x*b+y*C+d*F+p*A,r[10]=x*f+y*V+d*k+p*B,r[14]=x*S+y*P+d*T+p*R,r[3]=z*g+M*E+w*q+_*v,r[7]=z*b+M*C+w*F+_*A,r[11]=z*f+M*V+w*k+_*B,r[15]=z*S+M*P+w*T+_*R,this}multiplyScalar(t){const s=this.elements;return s[0]*=t,s[4]*=t,s[8]*=t,s[12]*=t,s[1]*=t,s[5]*=t,s[9]*=t,s[13]*=t,s[2]*=t,s[6]*=t,s[10]*=t,s[14]*=t,s[3]*=t,s[7]*=t,s[11]*=t,s[15]*=t,this}determinant(){const t=this.elements,s=t[0],i=t[4],e=t[8],r=t[12],h=t[1],n=t[5],a=t[9],o=t[13],c=t[2],l=t[6],u=t[10],m=t[14],x=t[3],y=t[7],d=t[11],p=t[15];return x*(+r*a*l-e*o*l-r*n*u+i*o*u+e*n*m-i*a*m)+y*(+s*a*m-s*o*u+r*h*u-e*h*m+e*o*c-r*a*c)+d*(+s*o*l-s*n*m-r*h*l+i*h*m+r*n*c-i*o*c)+p*(-e*n*c-s*a*l+s*n*u+e*h*l-i*h*u+i*a*c)}transpose(){const t=this.elements;let s;return s=t[1],t[1]=t[4],t[4]=s,s=t[2],t[2]=t[8],t[8]=s,s=t[6],t[6]=t[9],t[9]=s,s=t[3],t[3]=t[12],t[12]=s,s=t[7],t[7]=t[13],t[13]=s,s=t[11],t[11]=t[14],t[14]=s,this}setPosition(t,s,i){const e=this.elements;return t.isVector3?(e[12]=t.x,e[13]=t.y,e[14]=t.z):(e[12]=t,e[13]=s,e[14]=i),this}invert(){const t=this.elements,s=t[0],i=t[1],e=t[2],r=t[3],h=t[4],n=t[5],a=t[6],o=t[7],c=t[8],l=t[9],u=t[10],m=t[11],x=t[12],y=t[13],d=t[14],p=t[15],z=l*d*o-y*u*o+y*a*m-n*d*m-l*a*p+n*u*p,M=x*u*o-c*d*o-x*a*m+h*d*m+c*a*p-h*u*p,w=c*y*o-x*l*o+x*n*m-h*y*m-c*n*p+h*l*p,_=x*l*a-c*y*a-x*n*u+h*y*u+c*n*d-h*l*d,g=s*z+i*M+e*w+r*_;if(0===g)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const b=1/g;return t[0]=z*b,t[1]=(y*u*r-l*d*r-y*e*m+i*d*m+l*e*p-i*u*p)*b,t[2]=(n*d*r-y*a*r+y*e*o-i*d*o-n*e*p+i*a*p)*b,t[3]=(l*a*r-n*u*r-l*e*o+i*u*o+n*e*m-i*a*m)*b,t[4]=M*b,t[5]=(c*d*r-x*u*r+x*e*m-s*d*m-c*e*p+s*u*p)*b,t[6]=(x*a*r-h*d*r-x*e*o+s*d*o+h*e*p-s*a*p)*b,t[7]=(h*u*r-c*a*r+c*e*o-s*u*o-h*e*m+s*a*m)*b,t[8]=w*b,t[9]=(x*l*r-c*y*r-x*i*m+s*y*m+c*i*p-s*l*p)*b,t[10]=(h*y*r-x*n*r+x*i*o-s*y*o-h*i*p+s*n*p)*b,t[11]=(c*n*r-h*l*r-c*i*o+s*l*o+h*i*m-s*n*m)*b,t[12]=_*b,t[13]=(c*y*e-x*l*e+x*i*u-s*y*u-c*i*d+s*l*d)*b,t[14]=(x*n*e-h*y*e-x*i*a+s*y*a+h*i*d-s*n*d)*b,t[15]=(h*l*e-c*n*e+c*i*a-s*l*a-h*i*u+s*n*u)*b,this}scale(t){const s=this.elements,i=t.x,e=t.y,r=t.z;return s[0]*=i,s[4]*=e,s[8]*=r,s[1]*=i,s[5]*=e,s[9]*=r,s[2]*=i,s[6]*=e,s[10]*=r,s[3]*=i,s[7]*=e,s[11]*=r,this}getMaxScaleOnAxis(){const t=this.elements,s=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],i=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],e=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(s,i,e))}makeTranslation(t,s,i){return this.set(1,0,0,t,0,1,0,s,0,0,1,i,0,0,0,1),this}makeRotationX(t){const s=Math.cos(t),i=Math.sin(t);return this.set(1,0,0,0,0,s,-i,0,0,i,s,0,0,0,0,1),this}makeRotationY(t){const s=Math.cos(t),i=Math.sin(t);return this.set(s,0,i,0,0,1,0,0,-i,0,s,0,0,0,0,1),this}makeRotationZ(t){const s=Math.cos(t),i=Math.sin(t);return this.set(s,-i,0,0,i,s,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,s){const i=Math.cos(s),e=Math.sin(s),r=1-i,h=t.x,n=t.y,a=t.z,o=r*h,c=r*n;return this.set(o*h+i,o*n-e*a,o*a+e*n,0,o*n+e*a,c*n+i,c*a-e*h,0,o*a-e*n,c*a+e*h,r*a*a+i,0,0,0,0,1),this}makeScale(t,s,i){return this.set(t,0,0,0,0,s,0,0,0,0,i,0,0,0,0,1),this}makeShear(t,s,i,e,r,h){return this.set(1,i,r,0,t,1,h,0,s,e,1,0,0,0,0,1),this}compose(t,s,i){const e=this.elements,r=s._x,h=s._y,n=s._z,a=s._w,o=r+r,c=h+h,l=n+n,u=r*o,m=r*c,x=r*l,y=h*c,d=h*l,p=n*l,z=a*o,M=a*c,w=a*l,_=i.x,g=i.y,b=i.z;return e[0]=(1-(y+p))*_,e[1]=(m+w)*_,e[2]=(x-M)*_,e[3]=0,e[4]=(m-w)*g,e[5]=(1-(u+p))*g,e[6]=(d+z)*g,e[7]=0,e[8]=(x+M)*b,e[9]=(d-z)*b,e[10]=(1-(u+y))*b,e[11]=0,e[12]=t.x,e[13]=t.y,e[14]=t.z,e[15]=1,this}decompose(t,s,i){const e=this.elements;let r=l.set(e[0],e[1],e[2]).length();const h=l.set(e[4],e[5],e[6]).length(),n=l.set(e[8],e[9],e[10]).length(),a=this.determinant();a<0&&(r=-r),t.x=e[12],t.y=e[13],t.z=e[14],u.copy(this);const o=1/r,c=1/h,m=1/n;return u.elements[0]*=o,u.elements[1]*=o,u.elements[2]*=o,u.elements[4]*=c,u.elements[5]*=c,u.elements[6]*=c,u.elements[8]*=m,u.elements[9]*=m,u.elements[10]*=m,s.setFromRotationMatrix(u),i.x=r,i.y=h,i.z=n,this}makePerspective(t,s,i,e,r,h){void 0===h&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");const n=this.elements,a=2*r/(s-t),o=2*r/(i-e),c=(s+t)/(s-t),l=(i+e)/(i-e),u=-(h+r)/(h-r),m=-2*h*r/(h-r);return n[0]=a,n[4]=0,n[8]=c,n[12]=0,n[1]=0,n[5]=o,n[9]=l,n[13]=0,n[2]=0,n[6]=0,n[10]=u,n[14]=m,n[3]=0,n[7]=0,n[11]=-1,n[15]=0,this}makeOrthographic(t,s,i,e,r,h){const n=this.elements,a=1/(s-t),o=1/(i-e),c=1/(h-r),l=(s+t)*a,u=(i+e)*o,m=(h+r)*c;return n[0]=2*a,n[4]=0,n[8]=0,n[12]=-l,n[1]=0,n[5]=2*o,n[9]=0,n[13]=-u,n[2]=0,n[6]=0,n[10]=-2*c,n[14]=-m,n[3]=0,n[7]=0,n[11]=0,n[15]=1,this}equals(t){const s=this.elements,i=t.elements;for(let e=0;e<16;e++)if(s[e]!==i[e])return!1;return!0}fromArray(t,s=0){for(let i=0;i<16;i++)this.elements[i]=t[i+s];return this}toArray(t=[],s=0){const i=this.elements;return t[s]=i[0],t[s+1]=i[1],t[s+2]=i[2],t[s+3]=i[3],t[s+4]=i[4],t[s+5]=i[5],t[s+6]=i[6],t[s+7]=i[7],t[s+8]=i[8],t[s+9]=i[9],t[s+10]=i[10],t[s+11]=i[11],t[s+12]=i[12],t[s+13]=i[13],t[s+14]=i[14],t[s+15]=i[15],t}}c.prototype.isMatrix4=!0;const l=new n,u=new c,m=new n(0,0,0),x=new n(1,1,1),y=new n,d=new n,p=new n;class z{constructor(t=0,s=0){this.x=t,this.y=s}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,s){return this.x=t,this.y=s,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,s){switch(t){case 0:this.x=s;break;case 1:this.y=s;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t,s){return void 0!==s?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,s)):(this.x+=t.x,this.y+=t.y,this)}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,s){return this.x=t.x+s.x,this.y=t.y+s.y,this}addScaledVector(t,s){return this.x+=t.x*s,this.y+=t.y*s,this}sub(t,s){return void 0!==s?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,s)):(this.x-=t.x,this.y-=t.y,this)}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,s){return this.x=t.x-s.x,this.y=t.y-s.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const s=this.x,i=this.y,e=t.elements;return this.x=e[0]*s+e[3]*i+e[6],this.y=e[1]*s+e[4]*i+e[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,s){return this.x=Math.max(t.x,Math.min(s.x,this.x)),this.y=Math.max(t.y,Math.min(s.y,this.y)),this}clampScalar(t,s){return this.x=Math.max(t,Math.min(s,this.x)),this.y=Math.max(t,Math.min(s,this.y)),this}clampLength(t,s){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(t,Math.min(s,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){const t=Math.atan2(-this.y,-this.x)+Math.PI;return t}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const s=this.x-t.x,i=this.y-t.y;return s*s+i*i}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,s){return this.x+=(t.x-this.x)*s,this.y+=(t.y-this.y)*s,this}lerpVectors(t,s,i){return this.x=t.x+(s.x-t.x)*i,this.y=t.y+(s.y-t.y)*i,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,s=0){return this.x=t[s],this.y=t[s+1],this}toArray(t=[],s=0){return t[s]=this.x,t[s+1]=this.y,t}fromBufferAttribute(t,s,i){return void 0!==i&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(s),this.y=t.getY(s),this}rotateAround(t,s){const i=Math.cos(s),e=Math.sin(s),r=this.x-t.x,h=this.y-t.y;return this.x=r*i-h*e+t.x,this.y=r*e+h*i+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}z.prototype.isVector2=!0;class M{constructor(t=0,s=0,i=0,e=1){this.x=t,this.y=s,this.z=i,this.w=e}get width(){return this.z}set width(t){this.z=t}get height(){return this.w}set height(t){this.w=t}set(t,s,i,e){return this.x=t,this.y=s,this.z=i,this.w=e,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this.w=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setW(t){return this.w=t,this}setComponent(t,s){switch(t){case 0:this.x=s;break;case 1:this.y=s;break;case 2:this.z=s;break;case 3:this.w=s;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=void 0!==t.w?t.w:1,this}add(t,s){return void 0!==s?(console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,s)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this.w+=t,this}addVectors(t,s){return this.x=t.x+s.x,this.y=t.y+s.y,this.z=t.z+s.z,this.w=t.w+s.w,this}addScaledVector(t,s){return this.x+=t.x*s,this.y+=t.y*s,this.z+=t.z*s,this.w+=t.w*s,this}sub(t,s){return void 0!==s?(console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,s)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this.w-=t,this}subVectors(t,s){return this.x=t.x-s.x,this.y=t.y-s.y,this.z=t.z-s.z,this.w=t.w-s.w,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}applyMatrix4(t){const s=this.x,i=this.y,e=this.z,r=this.w,h=t.elements;return this.x=h[0]*s+h[4]*i+h[8]*e+h[12]*r,this.y=h[1]*s+h[5]*i+h[9]*e+h[13]*r,this.z=h[2]*s+h[6]*i+h[10]*e+h[14]*r,this.w=h[3]*s+h[7]*i+h[11]*e+h[15]*r,this}divideScalar(t){return this.multiplyScalar(1/t)}setAxisAngleFromQuaternion(t){this.w=2*Math.acos(t.w);const s=Math.sqrt(1-t.w*t.w);return s<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=t.x/s,this.y=t.y/s,this.z=t.z/s),this}setAxisAngleFromRotationMatrix(t){let s,i,e,r;const h=.01,n=.1,a=t.elements,o=a[0],c=a[4],l=a[8],u=a[1],m=a[5],x=a[9],y=a[2],d=a[6],p=a[10];if(Math.abs(c-u)<h&&Math.abs(l-y)<h&&Math.abs(x-d)<h){if(Math.abs(c+u)<n&&Math.abs(l+y)<n&&Math.abs(x+d)<n&&Math.abs(o+m+p-3)<n)return this.set(1,0,0,0),this;s=Math.PI;const t=(o+1)/2,a=(m+1)/2,z=(p+1)/2,M=(c+u)/4,w=(l+y)/4,_=(x+d)/4;return t>a&&t>z?t<h?(i=0,e=.707106781,r=.707106781):(i=Math.sqrt(t),e=M/i,r=w/i):a>z?a<h?(i=.707106781,e=0,r=.707106781):(e=Math.sqrt(a),i=M/e,r=_/e):z<h?(i=.707106781,e=.707106781,r=0):(r=Math.sqrt(z),i=w/r,e=_/r),this.set(i,e,r,s),this}let z=Math.sqrt((d-x)*(d-x)+(l-y)*(l-y)+(u-c)*(u-c));return Math.abs(z)<.001&&(z=1),this.x=(d-x)/z,this.y=(l-y)/z,this.z=(u-c)/z,this.w=Math.acos((o+m+p-1)/2),this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this.w=Math.min(this.w,t.w),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this.w=Math.max(this.w,t.w),this}clamp(t,s){return this.x=Math.max(t.x,Math.min(s.x,this.x)),this.y=Math.max(t.y,Math.min(s.y,this.y)),this.z=Math.max(t.z,Math.min(s.z,this.z)),this.w=Math.max(t.w,Math.min(s.w,this.w)),this}clampScalar(t,s){return this.x=Math.max(t,Math.min(s,this.x)),this.y=Math.max(t,Math.min(s,this.y)),this.z=Math.max(t,Math.min(s,this.z)),this.w=Math.max(t,Math.min(s,this.w)),this}clampLength(t,s){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(t,Math.min(s,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,s){return this.x+=(t.x-this.x)*s,this.y+=(t.y-this.y)*s,this.z+=(t.z-this.z)*s,this.w+=(t.w-this.w)*s,this}lerpVectors(t,s,i){return this.x=t.x+(s.x-t.x)*i,this.y=t.y+(s.y-t.y)*i,this.z=t.z+(s.z-t.z)*i,this.w=t.w+(s.w-t.w)*i,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}fromArray(t,s=0){return this.x=t[s],this.y=t[s+1],this.z=t[s+2],this.w=t[s+3],this}toArray(t=[],s=0){return t[s]=this.x,t[s+1]=this.y,t[s+2]=this.z,t[s+3]=this.w,t}fromBufferAttribute(t,s,i){return void 0!==i&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(s),this.y=t.getY(s),this.z=t.getZ(s),this.w=t.getW(s),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}M.prototype.isVector4=!0;class w{constructor(t=new n(1/0,1/0,1/0),s=new n(-1/0,-1/0,-1/0)){this.min=t,this.max=s}set(t,s){return this.min.copy(t),this.max.copy(s),this}setFromArray(t){let s=1/0,i=1/0,e=1/0,r=-1/0,h=-1/0,n=-1/0;for(let a=0,o=t.length;a<o;a+=3){const o=t[a],c=t[a+1],l=t[a+2];o<s&&(s=o),c<i&&(i=c),l<e&&(e=l),o>r&&(r=o),c>h&&(h=c),l>n&&(n=l)}return this.min.set(s,i,e),this.max.set(r,h,n),this}setFromBufferAttribute(t){let s=1/0,i=1/0,e=1/0,r=-1/0,h=-1/0,n=-1/0;for(let a=0,o=t.count;a<o;a++){const o=t.getX(a),c=t.getY(a),l=t.getZ(a);o<s&&(s=o),c<i&&(i=c),l<e&&(e=l),o>r&&(r=o),c>h&&(h=c),l>n&&(n=l)}return this.min.set(s,i,e),this.max.set(r,h,n),this}setFromPoints(t){this.makeEmpty();for(let s=0,i=t.length;s<i;s++)this.expandByPoint(t[s]);return this}setFromCenterAndSize(t,s){const i=g.copy(s).multiplyScalar(.5);return this.min.copy(t).sub(i),this.max.copy(t).add(i),this}setFromObject(t,s=!1){return this.makeEmpty(),this.expandByObject(t,s)}clone(){return(new this.constructor).copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(t){return this.isEmpty()?t.set(0,0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}expandByObject(t,s=!1){t.updateWorldMatrix(!1,!1);const i=t.geometry;if(void 0!==i)if(s&&void 0!=i.attributes&&void 0!==i.attributes.position){const s=i.attributes.position;for(let i=0,e=s.count;i<e;i++)g.fromBufferAttribute(s,i).applyMatrix4(t.matrixWorld),this.expandByPoint(g)}else null===i.boundingBox&&i.computeBoundingBox(),b.copy(i.boundingBox),b.applyMatrix4(t.matrixWorld),this.union(b);const e=t.children;for(let r=0,h=e.length;r<h;r++)this.expandByObject(e[r],s);return this}containsPoint(t){return!(t.x<this.min.x||t.x>this.max.x||t.y<this.min.y||t.y>this.max.y||t.z<this.min.z||t.z>this.max.z)}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y&&this.min.z<=t.min.z&&t.max.z<=this.max.z}getParameter(t,s){return s.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y),(t.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(t){return!(t.max.x<this.min.x||t.min.x>this.max.x||t.max.y<this.min.y||t.min.y>this.max.y||t.max.z<this.min.z||t.min.z>this.max.z)}intersectsSphere(t){return this.clampPoint(t.center,g),g.distanceToSquared(t.center)<=t.radius*t.radius}intersectsPlane(t){let s,i;return t.normal.x>0?(s=t.normal.x*this.min.x,i=t.normal.x*this.max.x):(s=t.normal.x*this.max.x,i=t.normal.x*this.min.x),t.normal.y>0?(s+=t.normal.y*this.min.y,i+=t.normal.y*this.max.y):(s+=t.normal.y*this.max.y,i+=t.normal.y*this.min.y),t.normal.z>0?(s+=t.normal.z*this.min.z,i+=t.normal.z*this.max.z):(s+=t.normal.z*this.max.z,i+=t.normal.z*this.min.z),s<=-t.constant&&i>=-t.constant}intersectsTriangle(t){if(this.isEmpty())return!1;this.getCenter(q),F.subVectors(this.max,q),f.subVectors(t.a,q),S.subVectors(t.b,q),E.subVectors(t.c,q),C.subVectors(S,f),V.subVectors(E,S),P.subVectors(f,E);let s=[0,-C.z,C.y,0,-V.z,V.y,0,-P.z,P.y,C.z,0,-C.x,V.z,0,-V.x,P.z,0,-P.x,-C.y,C.x,0,-V.y,V.x,0,-P.y,P.x,0];return!!v(s,f,S,E,F)&&(s=[1,0,0,0,1,0,0,0,1],!!v(s,f,S,E,F)&&(k.crossVectors(C,V),s=[k.x,k.y,k.z],v(s,f,S,E,F)))}clampPoint(t,s){return s.copy(t).clamp(this.min,this.max)}distanceToPoint(t){const s=g.copy(t).clamp(this.min,this.max);return s.sub(t).length()}getBoundingSphere(t){return this.getCenter(t.center),t.radius=.5*this.getSize(g).length(),t}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}applyMatrix4(t){return this.isEmpty()||(_[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(t),_[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(t),_[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(t),_[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(t),_[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(t),_[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(t),_[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(t),_[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(t),this.setFromPoints(_)),this}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}w.prototype.isBox3=!0;const _=[new n,new n,new n,new n,new n,new n,new n,new n],g=new n,b=new w,f=new n,S=new n,E=new n,C=new n,V=new n,P=new n,q=new n,F=new n,k=new n,T=new n;function v(t,s,i,e,r){for(let h=0,n=t.length-3;h<=n;h+=3){T.fromArray(t,h);const n=r.x*Math.abs(T.x)+r.y*Math.abs(T.y)+r.z*Math.abs(T.z),a=s.dot(T),o=i.dot(T),c=e.dot(T);if(Math.max(-Math.max(a,o,c),Math.min(a,o,c))>n)return!1}return!0}const A=new w,B=new n,R=new n,Z=new n;class H{constructor(t=new n,s=-1){this.center=t,this.radius=s}set(t,s){return this.center.copy(t),this.radius=s,this}setFromPoints(t,s){const i=this.center;void 0!==s?i.copy(s):A.setFromPoints(t).getCenter(i);let e=0;for(let r=0,h=t.length;r<h;r++)e=Math.max(e,i.distanceToSquared(t[r]));return this.radius=Math.sqrt(e),this}copy(t){return this.center.copy(t.center),this.radius=t.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(t){return t.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(t){return t.distanceTo(this.center)-this.radius}intersectsSphere(t){const s=this.radius+t.radius;return t.center.distanceToSquared(this.center)<=s*s}intersectsBox(t){return t.intersectsSphere(this)}intersectsPlane(t){return Math.abs(t.distanceToPoint(this.center))<=this.radius}clampPoint(t,s){const i=this.center.distanceToSquared(t);return s.copy(t),i>this.radius*this.radius&&(s.sub(this.center).normalize(),s.multiplyScalar(this.radius).add(this.center)),s}getBoundingBox(t){return this.isEmpty()?(t.makeEmpty(),t):(t.set(this.center,this.center),t.expandByScalar(this.radius),t)}applyMatrix4(t){return this.center.applyMatrix4(t),this.radius=this.radius*t.getMaxScaleOnAxis(),this}translate(t){return this.center.add(t),this}expandByPoint(t){Z.subVectors(t,this.center);const s=Z.lengthSq();if(s>this.radius*this.radius){const t=Math.sqrt(s),i=.5*(t-this.radius);this.center.add(Z.multiplyScalar(i/t)),this.radius+=i}return this}union(t){return!0===this.center.equals(t.center)?R.set(0,0,1).multiplyScalar(t.radius):R.subVectors(t.center,this.center).normalize().multiplyScalar(t.radius),this.expandByPoint(B.copy(t.center).add(R)),this.expandByPoint(B.copy(t.center).sub(R)),this}equals(t){return t.center.equals(this.center)&&t.radius===this.radius}clone(){return(new this.constructor).copy(this)}}class X{constructor(){this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}set(t,s,i,e,r,h,n,a,o){const c=this.elements;return c[0]=t,c[1]=e,c[2]=n,c[3]=s,c[4]=r,c[5]=a,c[6]=i,c[7]=h,c[8]=o,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(t){const s=this.elements,i=t.elements;return s[0]=i[0],s[1]=i[1],s[2]=i[2],s[3]=i[3],s[4]=i[4],s[5]=i[5],s[6]=i[6],s[7]=i[7],s[8]=i[8],this}extractBasis(t,s,i){return t.setFromMatrix3Column(this,0),s.setFromMatrix3Column(this,1),i.setFromMatrix3Column(this,2),this}setFromMatrix4(t){const s=t.elements;return this.set(s[0],s[4],s[8],s[1],s[5],s[9],s[2],s[6],s[10]),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,s){const i=t.elements,e=s.elements,r=this.elements,h=i[0],n=i[3],a=i[6],o=i[1],c=i[4],l=i[7],u=i[2],m=i[5],x=i[8],y=e[0],d=e[3],p=e[6],z=e[1],M=e[4],w=e[7],_=e[2],g=e[5],b=e[8];return r[0]=h*y+n*z+a*_,r[3]=h*d+n*M+a*g,r[6]=h*p+n*w+a*b,r[1]=o*y+c*z+l*_,r[4]=o*d+c*M+l*g,r[7]=o*p+c*w+l*b,r[2]=u*y+m*z+x*_,r[5]=u*d+m*M+x*g,r[8]=u*p+m*w+x*b,this}multiplyScalar(t){const s=this.elements;return s[0]*=t,s[3]*=t,s[6]*=t,s[1]*=t,s[4]*=t,s[7]*=t,s[2]*=t,s[5]*=t,s[8]*=t,this}determinant(){const t=this.elements,s=t[0],i=t[1],e=t[2],r=t[3],h=t[4],n=t[5],a=t[6],o=t[7],c=t[8];return s*h*c-s*n*o-i*r*c+i*n*a+e*r*o-e*h*a}invert(){const t=this.elements,s=t[0],i=t[1],e=t[2],r=t[3],h=t[4],n=t[5],a=t[6],o=t[7],c=t[8],l=c*h-n*o,u=n*a-c*r,m=o*r-h*a,x=s*l+i*u+e*m;if(0===x)return this.set(0,0,0,0,0,0,0,0,0);const y=1/x;return t[0]=l*y,t[1]=(e*o-c*i)*y,t[2]=(n*i-e*h)*y,t[3]=u*y,t[4]=(c*s-e*a)*y,t[5]=(e*r-n*s)*y,t[6]=m*y,t[7]=(i*a-o*s)*y,t[8]=(h*s-i*r)*y,this}transpose(){let t;const s=this.elements;return t=s[1],s[1]=s[3],s[3]=t,t=s[2],s[2]=s[6],s[6]=t,t=s[5],s[5]=s[7],s[7]=t,this}getNormalMatrix(t){return this.setFromMatrix4(t).invert().transpose()}transposeIntoArray(t){const s=this.elements;return t[0]=s[0],t[1]=s[3],t[2]=s[6],t[3]=s[1],t[4]=s[4],t[5]=s[7],t[6]=s[2],t[7]=s[5],t[8]=s[8],this}setUvTransform(t,s,i,e,r,h,n){const a=Math.cos(r),o=Math.sin(r);return this.set(i*a,i*o,-i*(a*h+o*n)+h+t,-e*o,e*a,-e*(-o*h+a*n)+n+s,0,0,1),this}scale(t,s){const i=this.elements;return i[0]*=t,i[3]*=t,i[6]*=t,i[1]*=s,i[4]*=s,i[7]*=s,this}rotate(t){const s=Math.cos(t),i=Math.sin(t),e=this.elements,r=e[0],h=e[3],n=e[6],a=e[1],o=e[4],c=e[7];return e[0]=s*r+i*a,e[3]=s*h+i*o,e[6]=s*n+i*c,e[1]=-i*r+s*a,e[4]=-i*h+s*o,e[7]=-i*n+s*c,this}translate(t,s){const i=this.elements;return i[0]+=t*i[2],i[3]+=t*i[5],i[6]+=t*i[8],i[1]+=s*i[2],i[4]+=s*i[5],i[7]+=s*i[8],this}equals(t){const s=this.elements,i=t.elements;for(let e=0;e<9;e++)if(s[e]!==i[e])return!1;return!0}fromArray(t,s=0){for(let i=0;i<9;i++)this.elements[i]=t[i+s];return this}toArray(t=[],s=0){const i=this.elements;return t[s]=i[0],t[s+1]=i[1],t[s+2]=i[2],t[s+3]=i[3],t[s+4]=i[4],t[s+5]=i[5],t[s+6]=i[6],t[s+7]=i[7],t[s+8]=i[8],t}clone(){return(new this.constructor).fromArray(this.elements)}}X.prototype.isMatrix3=!0;const Y=new n,j=new n,Q=new X;class I{constructor(t=new n(1,0,0),s=0){this.normal=t,this.constant=s}set(t,s){return this.normal.copy(t),this.constant=s,this}setComponents(t,s,i,e){return this.normal.set(t,s,i),this.constant=e,this}setFromNormalAndCoplanarPoint(t,s){return this.normal.copy(t),this.constant=-s.dot(this.normal),this}setFromCoplanarPoints(t,s,i){const e=Y.subVectors(i,s).cross(j.subVectors(t,s)).normalize();return this.setFromNormalAndCoplanarPoint(e,t),this}copy(t){return this.normal.copy(t.normal),this.constant=t.constant,this}normalize(){const t=1/this.normal.length();return this.normal.multiplyScalar(t),this.constant*=t,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(t){return this.normal.dot(t)+this.constant}distanceToSphere(t){return this.distanceToPoint(t.center)-t.radius}projectPoint(t,s){return s.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)}intersectLine(t,s){const i=t.delta(Y),e=this.normal.dot(i);if(0===e)return 0===this.distanceToPoint(t.start)?s.copy(t.start):null;const r=-(t.start.dot(this.normal)+this.constant)/e;return r<0||r>1?null:s.copy(i).multiplyScalar(r).add(t.start)}intersectsLine(t){const s=this.distanceToPoint(t.start),i=this.distanceToPoint(t.end);return s<0&&i>0||i<0&&s>0}intersectsBox(t){return t.intersectsPlane(this)}intersectsSphere(t){return t.intersectsPlane(this)}coplanarPoint(t){return t.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(t,s){const i=s||Q.getNormalMatrix(t),e=this.coplanarPoint(Y).applyMatrix4(t),r=this.normal.applyMatrix3(i).normalize();return this.constant=-e.dot(r),this}translate(t){return this.constant-=t.dot(this.normal),this}equals(t){return t.normal.equals(this.normal)&&t.constant===this.constant}clone(){return(new this.constructor).copy(this)}}I.prototype.isPlane=!0;const O=new H,U=new n;class W{constructor(t=new I,s=new I,i=new I,e=new I,r=new I,h=new I){this.planes=[t,s,i,e,r,h]}set(t,s,i,e,r,h){const n=this.planes;return n[0].copy(t),n[1].copy(s),n[2].copy(i),n[3].copy(e),n[4].copy(r),n[5].copy(h),this}copy(t){const s=this.planes;for(let i=0;i<6;i++)s[i].copy(t.planes[i]);return this}setFromProjectionMatrix(t){const s=this.planes,i=t.elements,e=i[0],r=i[1],h=i[2],n=i[3],a=i[4],o=i[5],c=i[6],l=i[7],u=i[8],m=i[9],x=i[10],y=i[11],d=i[12],p=i[13],z=i[14],M=i[15];return s[0].setComponents(n-e,l-a,y-u,M-d).normalize(),s[1].setComponents(n+e,l+a,y+u,M+d).normalize(),s[2].setComponents(n+r,l+o,y+m,M+p).normalize(),s[3].setComponents(n-r,l-o,y-m,M-p).normalize(),s[4].setComponents(n-h,l-c,y-x,M-z).normalize(),s[5].setComponents(n+h,l+c,y+x,M+z).normalize(),this}intersectsObject(t){const s=t.geometry;return null===s.boundingSphere&&s.computeBoundingSphere(),O.copy(s.boundingSphere).applyMatrix4(t.matrixWorld),this.intersectsSphere(O)}intersectsSprite(t){return O.center.set(0,0,0),O.radius=.7071067811865476,O.applyMatrix4(t.matrixWorld),this.intersectsSphere(O)}intersectsSphere(t){const s=this.planes,i=t.center,e=-t.radius;for(let r=0;r<6;r++){const t=s[r].distanceToPoint(i);if(t<e)return!1}return!0}intersectsBox(t){const s=this.planes;for(let i=0;i<6;i++){const e=s[i];if(U.x=e.normal.x>0?t.max.x:t.min.x,U.y=e.normal.y>0?t.max.y:t.min.y,U.z=e.normal.z>0?t.max.z:t.min.z,e.distanceToPoint(U)<0)return!1}return!0}containsPoint(t){const s=this.planes;for(let i=0;i<6;i++)if(s[i].distanceToPoint(t)<0)return!1;return!0}clone(){return(new this.constructor).copy(this)}}const L=new c,N=new n,D=new n;class J{constructor(t){this.camera=t,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new z(512,512),this.map=null,this.mapPass=null,this.matrix=new c,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new W,this._frameExtents=new z(1,1),this._viewportCount=1,this._viewports=[new M(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(t){const s=this.camera,i=this.matrix;N.setFromMatrixPosition(t.matrixWorld),s.position.copy(N),D.setFromMatrixPosition(t.target.matrixWorld),s.lookAt(D),s.updateMatrixWorld(),L.multiplyMatrices(s.projectionMatrix,s.matrixWorldInverse),this._frustum.setFromProjectionMatrix(L),i.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),i.multiply(s.projectionMatrix),i.multiply(s.matrixWorldInverse)}getViewport(t){return this._viewports[t]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(t){return this.camera=t.camera.clone(),this.bias=t.bias,this.radius=t.radius,this.mapSize.copy(t.mapSize),this}clone(){return(new this.constructor).copy(this)}toJSON(){const t={};return 0!==this.bias&&(t.bias=this.bias),0!==this.normalBias&&(t.normalBias=this.normalBias),1!==this.radius&&(t.radius=this.radius),512===this.mapSize.x&&512===this.mapSize.y||(t.mapSize=this.mapSize.toArray()),t.camera=this.camera.toJSON(!1).object,delete t.camera.matrix,t}}}}]);